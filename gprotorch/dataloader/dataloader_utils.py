"""
A script containing utilities for the different data loader classes.
"""

import sys
from prody import *
import pandas as pd
from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit.Chem.Descriptors import qed
from io import StringIO
import requests
import os
import oddt
import numpy as np
from oddt.toolkits import rdk
from oddt.scoring.descriptors import binana
from oddt.fingerprints import PLEC
from rdkit.Chem import AllChem, Descriptors, MolFromSmiles

confProDy(verbosity='none')

# -------------------------------- PDB scraping utilities --------------------------------

# functions adapted from Pat Walters (https://gist.github.com/PatWalters/3c0a483c030a2c75cb22c4234f206973)
# that split a PDB entry into a .pdb file of the protein and a .sdf file of the ligand(s)


def read_ligand_expo():
    """
    Read PDB Ligand Expo data, try to find a file called
    Components-smiles-stereo-oe.smi in the current directory.
    If you can't find the file, grab it from the RCSB

    Returns: Ligand Expo as a dictionary with ligand id as the key

    """

    file_name = "Components-smiles-stereo-oe.smi"

    # read file if it already exists
    try:
        df = pd.read_csv(file_name, sep="\t",
                         header=None,
                         names=["SMILES", "ID", "Name"])

    # otherwise download it and read it in afterwards
    except FileNotFoundError:
        url = f"http://ligand-expo.rcsb.org/dictionaries/{file_name}"
        r = requests.get(url, allow_redirects=True)
        open('Components-smiles-stereo-oe.smi', 'wb').write(r.content)
        df = pd.read_csv(file_name, sep="\t",
                         header=None,
                         names=["SMILES", "ID", "Name"])
    df.set_index("ID", inplace=True)

    return df.to_dict()


def get_pdb_components(pdb_id):
    """
    Split a protein-ligand pdb into protein and ligand components.
    A useful dictionary of possible flags can be found here
    http://prody.csb.pitt.edu/manual/reference/atomic/flags.html#flags.

    Args:
        pdb_id: 4-letter pdb code

    Returns: tuple of ProDy Selections for proteins and ligands

    """

    pdb = parsePDB(pdb_id)
    protein = pdb.select('protein')
    ligand = pdb.select('hetatm and not water and not ion')
    return protein, ligand


def process_ligand(ligand, res_name, expo_dict):
    """
    Add bond orders to a pdb ligand through the following process
    1. Select the ligand component with name "res_name"
    2. Get the corresponding SMILES from the Ligand Expo dictionary
    3. Create a template molecule from the SMILES in step 2
    4. Write the PDB file to a stream
    5. Read the stream into an RDKit molecule
    6. Assign the bond orders from the template from step 3

    Args:
        ligand: ligand as generated by prody
        res_name: residue name of ligand to extract
        expo_dict: dictionary with LigandExpo

    Returns: molecule with bond orders assigned

    """

    output = StringIO()

    # select res_name residue
    sub_mol = ligand.select(f"resname {res_name}")

    # extract corresponding SMILES and read it into rdkit
    sub_smiles = expo_dict['SMILES'][res_name]
    template = AllChem.MolFromSmiles(sub_smiles)

    # calculate the rdkit drug likeness descripot for the ligand expo template
    drug_likeness = qed(template)

    # stream selected ligand
    writePDBStream(output, sub_mol)
    pdb_string = output.getvalue()

    # add bond orders
    rd_mol = AllChem.MolFromPDBBlock(pdb_string)
    new_mol = AllChem.AssignBondOrdersFromTemplate(template, rd_mol)

    return new_mol, drug_likeness


def write_pdb(protein, pdb_name, overwrite=False):
    """
    Write a prody protein to a pdb file.

    Args:
        protein: protein object from prody
        pdb_name: base name for the pdb file
        overwrite: whether to overwrite an already existing file

    Returns: file name

    """

    output_protein_name = f"{pdb_name}_protein.pdb"

    # check if file already exists
    if not overwrite and os.path.isfile(os.path.join(os.getcwd(), output_protein_name)):
        print(f"The protein file for the PDB entry {pdb_name} already exists. "
              f"Set overwrite=True if you want to overwrite it.")
    else:
        writePDB(output_protein_name, protein)
        print(f"Wrote the protein file for the PDB entry {output_protein_name}.")

    return output_protein_name


def write_sdf(new_mol, pdb_name, res_name, overwrite=False):
    """
    Write an RDKit molecule to an SD file.

    Args:
        new_mol: the molecule to write to a file
        pdb_name: the PDB entry from which it was extracted
        res_name: its residue identifier in the PDB entry
        overwrite: whether to overwrite an already existing file

    Returns: file name

    """

    outfile_ligand_name = f"{pdb_name}_{res_name}_ligand.sdf"

    # check if file already exists
    if not overwrite and os.path.isfile(os.path.join(os.getcwd(), outfile_ligand_name)):
        print(f"The ligand file for the ligand {res_name} in PDB entry {pdb_name} already exists. "
              f"Set overwrite=True if you want to overwrite it.")
    else:
        writer = Chem.SDWriter(outfile_ligand_name)
        writer.write(new_mol)
        print(f"Wrote the ligand file for the ligand {res_name} in PDB entry {pdb_name}.")

    return outfile_ligand_name


def sdf_to_smiles(paths):
    """
    Extracts the SMILES representation from the molecules described
    in a list of paths to .sdf files.

    Args:
        paths: a list of paths to .sdf file containing molecules to be transcribed

    Returns: a list of SMILES.

    """

    if type(paths) is not list:
        paths = [paths]

    smiles_list = []

    # for all .sdf file paths
    for ligand_path in paths:
        # read in each molecule in the current .sdf file (should be just one)
        sppl = Chem.SDMolSupplier(ligand_path)

        # check if any molecules could be parsed, and if so
        # add them to SMILES list
        for mol in sppl:
            if mol is None:
                print(f"Could not parse SMILES representation of molecule in {ligand_path}.")
            else:
                smiles_list.append(Chem.MolToSmiles(mol))

    return smiles_list

# -------------------------------- featurisation utilities --------------------------------

def molecule_fingerprints(input_mols, bond_radius, nBits):
    """
    Auxiliary function to transform the loaded features to a fingerprint representation

    Returns: numpy array of features in fingerprint representation

    """

    rdkit_mols = [MolFromSmiles(smiles) for smiles in input_mols]
    fps = [
        AllChem.GetMorganFingerprintAsBitVect(mol, bond_radius, nBits=nBits)
        for mol in rdkit_mols
    ]

    return np.asarray(fps)


def molecule_fragments(input_mols, to_df=None):
    """
    Accepts a list of SMILES and calculates all rdkit fragment descriptorsd

    Args:
        input_mols: a list of SMILES to be convertes
        to_df: whether to return a DataFrame; if None, returns a numpy array,
        if not None, expects an index with which to create the dataframe

    Returns:

    """

    # extract all fragment rdkit descriptors
    # (https://www.rdkit.org/docs/source/rdkit.Chem.Fragments.html)
    fragList = [desc for desc in Descriptors.descList if desc[0].startswith('fr_')]

    fragments = {d[0]: d[1] for d in fragList}
    frags = np.zeros((len(input_mols), len(fragments)))
    for i in range(len(input_mols)):
        mol = MolFromSmiles(input_mols[i])
        try:
            features = [fragments[d](mol) for d in fragments]
        except:
            raise Exception("molecule {}".format(i) + " is not canonicalised")
        frags[i, :] = features

    if to_df is None:
        result = frags

    else:
        result = pd.DataFrame(
            data=frags,
            index=to_df,
            columns=[frag_desc[0] for frag_desc in fragments.items()]
        )

    return result


def vina_features(objects):
    """
    Calculates the AutoDock Vina fetures for a list of
    protein and ligand files.

    Args:
        objects: a list of (pdb_code, protein_path, ligand_path) tuples

    Returns: pandas DataFrame with the specified features

    """

    results = []

    vina_names = ['vina_gauss1', 'vina_gauss2', 'vina_repulsion',
                     'vina_hydrophobic', 'vina_hydrogen', 'vina_num_rotors']

    for pdb_code, protein_path, ligand_path in objects:

        # initialise protein and ligand
        protein = next(oddt.toolkit.readfile('pdb', protein_path))
        protein.protein = True
        ligand = next(oddt.toolkit.readfile('sdf', ligand_path))

        # initialise Vina feature engine for current protein
        vina_engine = oddt.scoring.descriptors.oddt_vina_descriptor(
            protein=protein,
            vina_scores=vina_names
        )

        # calculate vina features for respective ligand
        result = {name: value for name, value in zip(vina_engine.titles, vina_engine.build([ligand])[0])}

        results.append(result)

    results = pd.DataFrame(
        data=results,
        index=[i[0] for i in objects]
    )

    return results


def binana_nnscore_features(objects, feature_group):
    """
    Calulates either the BINANA features or the features used in NNScore v2
    (BINANA and AutoDock Vina features)

    Args:
        objects: a list of (pdb_code, protein_path, ligand_path) tuples
        feature_group: whether to extract 'binana' or 'nnscorev2' features

    Returns: list of specified features

    """

    results = []

    for pdb_code, protein_path, ligand_path in objects:

        # initialise protein and ligand
        protein = next(oddt.toolkit.readfile('pdb', protein_path))
        protein.protein = True
        ligand = next(oddt.toolkit.readfile('sdf', ligand_path))

        # initialise binana engine
        binana_engine = binana.binana_descriptor(protein)

        features_all = {name: value for name, value in zip(binana_engine.titles, binana_engine.build([ligand])[0])}

        # the ODDT names for the VINA features, missing 'num_rotors'
        vina_feature_names = ['vina_gauss1', 'vina_gauss2', 'vina_hydrogen',
                              'vina_hydrophobic', 'vina_repulsion']

        if feature_group == 'binana':

            # remove AutoDock Vina features and add "binana_" prefix to all features
            result = {'binana_' + k: v for k, v in features_all.items() if k not in vina_feature_names}

        elif feature_group == 'nnscorev2':

            # keep AutoDock Vina features and add "nnscorev2_" prefix to all features
            result = {'nnscorev2_' + k: v for k, v in features_all.items()}

        else:
            raise Exception(
                f"Internal error: feature selection {feature_group} not in "
                f"['binana', 'nnscorev2'] for binana_nnscore_features function."
            )

        results.append(result)

    results = pd.DataFrame(
        data=results,
        index=[i[0] for i in objects]
    )

    return results


def rfscore_descriptors(objects):
    """
    Calculates the features from RFScore v3, which are close-contact descriptors
    plus the AutoDock Vina features.

    Args:
        objects: a list of (pdb_code, protein_path, ligand_path) tuples

    Returns: list of specified features

    """

    results = []

    for pdb_code, protein_path, ligand_path in objects:

        # initialise protein and ligand
        protein = next(oddt.toolkit.readfile('pdb', protein_path))
        protein.protein = True
        ligand = next(oddt.toolkit.readfile('sdf', ligand_path))

        rfscore_engine = oddt.scoring.descriptors.close_contacts_descriptor(
            protein=protein,
            cutoff=12,
            ligand_types=[6, 7, 8, 9, 15, 16, 17, 35, 53],
            protein_types=[6, 7, 8, 16])
        result = {name: value for name, value in zip(rfscore_engine.titles, rfscore_engine.build([ligand])[0])}

        results.append(result)

    results = pd.DataFrame(data=results, index=[i[0] for i in objects])

    return results


def plec_fingerprints(objects, params):
    """
    Calculates the protein-ligand extended conncetivity fingerprints
    for the given proteins. The arguments and their standard values are
    plec_depth_ligand=2, plec_depth_protein=4,
    plec_distance_cutoff=4.5, plec_size=16384

    Args:
        objects: a list of (pdb_code, protein_path, ligand_path) tuples
        params: custom parameters passed to calculate PLEC FPs

    Returns: list of specified features

    """

    results = []

    # set standard parameters
    plec_params = {
        'plec_depth_ligand': 2,
        'plec_depth_protein': 4,
        'plec_distance_cutoff': 4.5,
        'plec_size': 16384,
    }

    # if parameter changes are passed through kwargs, apply them
    plec_params.update(params)

    for pdb_code, protein_path, ligand_path in objects:

        protein = next(oddt.toolkit.readfile('pdb', protein_path))
        protein.protein = True
        ligand = next(oddt.toolkit.readfile('sdf', ligand_path))

        result = PLEC(
            ligand=ligand,
            protein=protein,
            depth_ligand=plec_params['plec_depth_ligand'],
            depth_protein=plec_params['plec_depth_protein'],
            distance_cutoff=plec_params['plec_distance_cutoff'],
            size=plec_params['plec_size'],
            sparse=False
        )

        results.append(result)

    results = pd.DataFrame(
        data=results,
        index=[i[0] for i in objects],
        columns=["plec_"+str(i) for i in range(plec_params['plec_size'])])

    return results
